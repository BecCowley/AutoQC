import combineTests as combinatorics
import matplotlib.pyplot as plt
import numpy as np

def compare_to_truth(combos, trueResult):
    '''Given the results from all the possible combinations of tests (combos)
       and a set of truth results (trueResult), the false positive rate and the
       true positive rate (the rate at which the combination of test incorrectly
       reject a profile or correctly reject a profile, respectively) are 
       calculated (in %).
       
       Results are returned in an identical set of lists to combos except the
       quality control results are replaced by the false and true positive
       rates.
    '''

    benchmarks = []
    for combo in combos:
        tt = 0.0
        tf = 0.0
        ft = 0.0
        ff = 0.0
        for i in range(len(trueResult)):           
            if combo[1][i] == True and trueResult[i] == True:
                tt += 1
            elif combo[1][i] == True and trueResult[i] == False:
                tf += 1
            elif combo[1][i] == False and trueResult[i] == True:
                ft += 1
            else:
                ff += 1
                
        assert (tf + ff) > 0, 'No non-rejected profiles are available'
        assert (tt + ft) > 0, 'No rejected profiles are available'
        falsePositiveRate = tf / (tf + ff) * 100.0
        truePositiveRate = tt / (tt + ft) * 100.0
                        
        benchmarks.append([combo[0], 
                           [falsePositiveRate, truePositiveRate], 
                           combo[2]])

    return benchmarks

def plot_roc(bmResults):
    '''Plots the results generated by compare_to_truth and also prints
       the results to screen.
       
       The plot shows the true positive rate (the percentage of profiles that
       should be rejected that actually are rejected) against the false 
       positive rate (the percentage of profiles that should not have been 
       rejected but were). Ideally we would like a true positive rate of 100%
       and a false positive rate of 0%. The combinations that yield the lowest
       false positive rate are shown in red; the highest true positive rate
       combinations in blue and the closest to the ideal of 100% true positive
       rate and 0% false positive rate in green. Other combinations are shown
       by black crosses.
    '''

    # Results with the highest true positive rate, lowest false positive rate
    # and the closest to tpr = 100, fpr = 0 are highlighted.
    fpr = np.array([bmResults[i][1][0] for i in range(len(bmResults))])
    tpr = np.array([bmResults[i][1][1] for i in range(len(bmResults))])
    dists = np.sqrt(fpr**2 + (100.0 - tpr)**2) 
    
    lFpr  = fpr == np.min(fpr)
    lTpr  = tpr == np.max(tpr)
    lDist = dists == np.min(dists)
    
    for num, bm in enumerate(bmResults):
        printout = False       
        c = 'xk'
        if lFpr[num]:
            c = 'or'
            print '*** Lowest false positive rate ***'
            printout = True
        if lTpr[num]:
            c = 'ob'
            print '*** Highest true positive rate ***'
            printout = True
        if lDist[num]:
            c = 'og'
            print '*** Closest to FPR = 0 and TPR = 100 ***'
            printout = True
        
        if printout:
            print '  Combination ' + str(num+1) + ':'
            print '    ' + combinatorics.combinationStr(bm[0], bm[2])
            print '    False Positive Rate = {0:5.1f}%'.format(bm[1][0])
            print '    True Positive Rate  = {0:5.1f}%'.format(bm[1][1])
       
        
        plt.plot(bm[1][0], bm[1][1], c, label='Combo ' + str(num+1))

    plt.gca().set_xlim(0.0, 100.0)
    plt.gca().set_ylim(0.0, 100.0)
    plt.gca().set_xlabel('False positive rate (%)')
    plt.gca().set_ylabel('True positive rate (%)')
    
    plt.show()
